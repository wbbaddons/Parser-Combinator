'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _flowBundle = require('./flow-bundle');

var _flowBundle2 = _interopRequireDefault(_flowBundle);

var _parser = require('./parser');

var _parser2 = _interopRequireDefault(_parser);

var _response = require('./response');

var _response2 = _interopRequireDefault(_response);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// unit -> Parser char char
function letter() {
    return _flowBundle2.default.satisfy(function (v) {
        return 'a' <= v && v <= 'z' || 'A' <= v && v <= 'Z';
    });
} /*
   * Parsec
   * https://github.com/d-plaindoux/parsec
   *
   * Copyright (c) 2016 Didier Plaindoux
   * Licensed under the LGPL2 license.
   */


function isUtf8Letter(char) {
    var firstLetter = char.toUpperCase();
    return firstLetter.toLowerCase() != firstLetter;
}

function utf8Letter() {
    return _flowBundle2.default.satisfy(function (v) {
        return isUtf8Letter(v);
    });
}

function letters() {
    return letter().rep().map(function (values) {
        return values.join('');
    });
}

// char -> Parser char char
function char(c) {
    if (c.length !== 1) {
        throw new Error('Char parser must contains one character');
    }

    return _flowBundle2.default.satisfy(function (v) {
        return c === v;
    });
}

// char -> Parser char char
function notChar(c) {
    if (c.length !== 1) {
        throw new Error('Char parser must contains one character');
    }

    return _flowBundle2.default.satisfy(function (v) {
        return c !== v;
    });
}

// string -> Parser char char
function charIn(c) {
    return _flowBundle2.default.satisfy(function (v) {
        return c.indexOf(v) !== -1;
    });
}

// string -> Parser char char
function charNotIn(c) {
    return _flowBundle2.default.satisfy(function (v) {
        return c.indexOf(v) === -1;
    });
}

// int -> Parser string char
function subString(length) {
    return _flowBundle2.default.subStream(length).map(function (s) {
        return s.join('');
    });
}

// string -> Parser string char
function string(s) {
    return new _parser2.default(function (input) {
        var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        if (input.subStreamAt(s.split(''), index)) {
            return _response2.default.accept(s, input, index + s.length, true);
        } else {
            return _response2.default.reject(input.location(index), false);
        }
    });
}

// string -> Parser string char
function notString(s) {
    return _flowBundle2.default.not(string(s));
}

// unit -> Parser string char
function stringLiteral() {
    var anyChar = string('\\"').or(notChar('"'));
    return char('"').thenRight(anyChar.optrep()).thenLeft(char('"')).map(function (r) {
        return r.join('');
    });
}

// unit -> Parser char char
function charLiteral() {
    var anyChar = string("\\'").or(notChar("'"));
    return char("'").thenRight(anyChar).thenLeft(char("'"));
}

// unit -> Parser char char
function lowerCase() {
    return _flowBundle2.default.satisfy(function (v) {
        return 'a' <= v && v <= 'z';
    });
}

// unit -> Parser char char
function upperCase() {
    return _flowBundle2.default.satisfy(function (v) {
        return 'A' <= v && v <= 'Z';
    });
}

exports.default = {
    utf8Letter: utf8Letter(),
    letter: letter(),
    letters: letters(),
    notChar: notChar,
    char: char,
    charIn: charIn,
    charNotIn: charNotIn,
    subString: subString,
    string: string,
    notString: notString,
    charLiteral: charLiteral(),
    stringLiteral: stringLiteral(),
    lowerCase: lowerCase(),
    upperCase: upperCase()
};
//# sourceMappingURL=chars-bundle.js.map