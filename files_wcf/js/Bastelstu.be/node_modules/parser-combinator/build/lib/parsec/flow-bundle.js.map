{"version":3,"sources":["../../../src/lib/parsec/flow-bundle.js"],"names":["parse","p","lazy","parameters","input","index","apply","prototype","returns","v","accept","error","reject","location","eos","endOfStream","satisfy","predicate","get","filter","map","value","lazyRecoverWith","doTry","fold","offset","any","nop","not","then","or","subStream","length","occurrence","sequence","current","arguments","try"],"mappings":";;;;;;AAQA;;;;AACA;;;;AACA;;;;;;AAEA;AACA,SAASA,KAAT,CAAeC,CAAf,EAAkB;AACd,WAAO,qBAAWA,CAAX,CAAP;AACH;;AAED;AAjBA;;;;;;;;AAkBA,SAASC,IAAT,CAAcD,CAAd,EAAiBE,UAAjB,EAA6B;AACzB;AACA,WAAO,qBAAW,UAACC,KAAD;AAAA,YAAQC,KAAR,uEAAgB,CAAhB;AAAA,eACdJ,EAAEK,KAAF,CAAQL,EAAEM,SAAV,EAAqBJ,UAArB,EAAiCH,KAAjC,CAAuCI,KAAvC,EAA8CC,KAA9C,CADc;AAAA,KAAX,CAAP;AAGH;;AAED;AACA,SAASG,OAAT,CAAiBC,CAAjB,EAAoB;AAChB,WAAO,qBAAW,UAACL,KAAD;AAAA,YAAQC,KAAR,uEAAgB,CAAhB;AAAA,eACd,mBAASK,MAAT,CAAgBD,CAAhB,EAAmBL,KAAnB,EAA0BC,KAA1B,EAAiC,KAAjC,CADc;AAAA,KAAX,CAAP;AAGH;;AAED;AACA,SAASM,KAAT,GAAiB;AACb,WAAO,qBAAW,UAACP,KAAD;AAAA,YAAQC,KAAR,uEAAgB,CAAhB;AAAA,eACd,mBAASO,MAAT,CAAgBR,MAAMS,QAAN,CAAeR,KAAf,CAAhB,EAAuC,KAAvC,CADc;AAAA,KAAX,CAAP;AAGH;;AAED;AACA,SAASS,GAAT,GAAe;AACX,WAAO,qBAAW,UAACV,KAAD,EAAsB;AAAA,YAAdC,KAAc,uEAAN,CAAM;;AACpC,YAAID,MAAMW,WAAN,CAAkBV,KAAlB,CAAJ,EAA8B;AAC1B,mBAAO,mBAASK,MAAT,iBAAsBN,KAAtB,EAA6BC,KAA7B,EAAoC,KAApC,CAAP;AACH,SAFD,MAEO;AACH,mBAAO,mBAASO,MAAT,CAAgBR,MAAMS,QAAN,CAAeR,KAAf,CAAhB,EAAuC,KAAvC,CAAP;AACH;AACJ,KANM,CAAP;AAOH;;AAED;AACA,SAASW,OAAT,CAAiBC,SAAjB,EAA4B;AACxB,WAAO,qBAAW,UAACb,KAAD;AAAA,YAAQC,KAAR,uEAAgB,CAAhB;AAAA,eACdD,MACKc,GADL,CACSb,KADT,EAEKc,MAFL,CAEYF,SAFZ,EAGKG,GAHL,CAGS;AAAA,mBAAS,mBAASV,MAAT,CAAgBW,KAAhB,EAAuBjB,KAAvB,EAA8BC,QAAQ,CAAtC,EAAyC,IAAzC,CAAT;AAAA,SAHT,EAIKiB,eAJL,CAIqB;AAAA,mBACb,mBAASV,MAAT,CAAgBR,MAAMS,QAAN,CAAeR,KAAf,CAAhB,EAAuC,KAAvC,CADa;AAAA,SAJrB,CADc;AAAA,KAAX,CAAP;AASH;;AAED;AACA,SAASkB,KAAT,CAAetB,CAAf,EAAkB;AACd,WAAO,qBAAW,UAACG,KAAD;AAAA,YAAQC,KAAR,uEAAgB,CAAhB;AAAA,eACdJ,EACKD,KADL,CACWI,KADX,EACkBC,KADlB,EAEKmB,IAFL,CAGQ;AAAA,mBAAUd,MAAV;AAAA,SAHR,EAIQ;AAAA,mBAAU,mBAASE,MAAT,CAAgBR,MAAMS,QAAN,CAAeD,OAAOa,MAAtB,CAAhB,EAA+C,KAA/C,CAAV;AAAA,SAJR,CADc;AAAA,KAAX,CAAP;AAQH;;AAED;AACA,SAASC,GAAT,GAAe;AACX,WAAOV,QAAQ;AAAA,eAAM,IAAN;AAAA,KAAR,CAAP;AACH;;AAED;AACA,SAASW,GAAT,GAAe;AACX,WAAO,qBAAW,UAACvB,KAAD;AAAA,YAAQC,KAAR,uEAAgB,CAAhB;AAAA,eACd,mBAASK,MAAT,CAAgB,EAAhB,EAAoBN,KAApB,EAA2BC,KAA3B,EAAkC,IAAlC,CADc;AAAA,KAAX,CAAP;AAGH;;AAED;AACA,SAASuB,GAAT,CAAa3B,CAAb,EAAgB;AACZ,WAAOsB,MAAMtB,CAAN,EAAS4B,IAAT,CAAclB,OAAd,EAAuBmB,EAAvB,CAA0BJ,KAA1B,CAAP;AACH;;AAED;AACA,SAASK,SAAT,CAAmBC,MAAnB,EAA2B;AACvB,WAAON,MAAMO,UAAN,CAAiBD,MAAjB,CAAP;AACH;;AAED,SAASE,QAAT,GAAoB;AAChB,QAAIC,UAAUR,KAAd;AACA,SAAK,IAAIlB,CAAT,IAAc2B,SAAd,EAAyB;AACrBD,kBAAUA,QAAQN,IAAR,CAAaO,UAAU3B,CAAV,CAAb,CAAV;AACH;AACD,WAAO0B,OAAP;AACH;;kBAEc;AACXnC,gBADW;AAEXqC,SAAKd,KAFM;AAGXG,SAAKA,KAHM;AAIXK,eAAWA,SAJA;AAKXH,SAAKA,GALM;AAMX1B,UAAMA,IANK;AAOXM,aAASA,OAPE;AAQXG,WAAOA,OARI;AASXG,SAAKA,KATM;AAUXE,aAASA,OAVE;AAWXkB;AAXW,C","file":"flow-bundle.js","sourcesContent":["/*\r\n * Parsec\r\n * https://github.com/d-plaindoux/parsec\r\n *\r\n * Copyright (c) 2016 Didier Plaindoux\r\n * Licensed under the LGPL2 license.\r\n */\r\n\r\nimport unit from '../data/unit.js';\r\nimport Parser from './parser';\r\nimport response from './response';\r\n\r\n// (Stream 'c -> number -> Response 'a 'c) -> Parser 'a 'c\r\nfunction parse(p) {\r\n    return new Parser(p);\r\n}\r\n\r\n// (('b -> Parser 'a 'c) * 'b)-> Parser 'a 'c\r\nfunction lazy(p, parameters) {\r\n    // equivalent of p(...parameters), but would fail if parameters are undefined\r\n    return new Parser((input, index = 0) =>\r\n        p.apply(p.prototype, parameters).parse(input, index)\r\n    );\r\n}\r\n\r\n// 'a -> Parser 'a 'c\r\nfunction returns(v) {\r\n    return new Parser((input, index = 0) =>\r\n        response.accept(v, input, index, false)\r\n    );\r\n}\r\n\r\n// unit -> Parser 'a 'c\r\nfunction error() {\r\n    return new Parser((input, index = 0) =>\r\n        response.reject(input.location(index), false)\r\n    );\r\n}\r\n\r\n// unit -> Parser unit 'c\r\nfunction eos() {\r\n    return new Parser((input, index = 0) => {\r\n        if (input.endOfStream(index)) {\r\n            return response.accept(unit, input, index, false);\r\n        } else {\r\n            return response.reject(input.location(index), false);\r\n        }\r\n    });\r\n}\r\n\r\n// ('a -> boolean) -> Parser a 'c\r\nfunction satisfy(predicate) {\r\n    return new Parser((input, index = 0) =>\r\n        input\r\n            .get(index)\r\n            .filter(predicate)\r\n            .map(value => response.accept(value, input, index + 1, true))\r\n            .lazyRecoverWith(() =>\r\n                response.reject(input.location(index), false)\r\n            )\r\n    );\r\n}\r\n\r\n// Parser 'a 'c -> Parser 'a 'c\r\nfunction doTry(p) {\r\n    return new Parser((input, index = 0) =>\r\n        p\r\n            .parse(input, index)\r\n            .fold(\r\n                accept => accept,\r\n                reject => response.reject(input.location(reject.offset), false)\r\n            )\r\n    );\r\n}\r\n\r\n// unit -> Parser 'a 'c\r\nfunction any() {\r\n    return satisfy(() => true);\r\n}\r\n\r\n// unit -> Parser 'a 'c\r\nfunction nop() {\r\n    return new Parser((input, index = 0) =>\r\n        response.accept([], input, index, true)\r\n    );\r\n}\r\n\r\n// Parser 'a ? -> Parser 'a 'a\r\nfunction not(p) {\r\n    return doTry(p).then(error()).or(any());\r\n}\r\n\r\n// int -> Parser (List 'a') a'\r\nfunction subStream(length) {\r\n    return any().occurrence(length);\r\n}\r\n\r\nfunction sequence() {\r\n    var current = nop();\r\n    for (let v in arguments) {\r\n        current = current.then(arguments[v]);\r\n    }\r\n    return current;\r\n}\r\n\r\nexport default {\r\n    parse,\r\n    try: doTry,\r\n    any: any(),\r\n    subStream: subStream,\r\n    not: not,\r\n    lazy: lazy,\r\n    returns: returns,\r\n    error: error(),\r\n    eos: eos(),\r\n    satisfy: satisfy,\r\n    sequence,\r\n};\r\n"]}