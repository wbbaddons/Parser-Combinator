{"version":3,"sources":["../../../../src/lib/standard/extractor/extractor-bundle.js"],"names":["ExtractorBundle","options","spacesCharacters","wordSeparators","charIn","letter","moreSeparators","Object","assign","_handleOptions","last","_last","first","_first","console","warn","moreSeparator","rep","map","spaces","join","digit","parseInt","v","or","keepSpaces","try","word","_wordSeparators","item","array","parser","optrep","thenRight","thenLeft","stringIn","tryString","string","s","length","thenReturns","undefined","initial","workArray","slice","reduce","accu","next","stop","not","satisfyStringFast","Array","isArray","satisfyArrayStringFast","_wordSequence","then","eos","chars","filter","values","input","index","source","sourceIndex","indexOf","accept","substring","reject","location","i","needle"],"mappings":"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","file":"extractor-bundle.js","sourcesContent":["import {F, C, N} from '../../index';\r\nimport response from './../../parsec/response';\r\nimport Parser from './../../parsec/parser';\r\n\r\n/**\r\n * Created by nicorama on 10/01/2017.\r\n */\r\n\r\nexport default class ExtractorBundle {\r\n    constructor(options) {\r\n        this.options = {\r\n            spacesCharacters: ' \\t\\n',\r\n            wordSeparators: C.charIn(' \\n:-,;'),\r\n            letter: C.letter,\r\n            moreSeparators: null,\r\n        };\r\n\r\n        Object.assign(this.options, this._handleOptions(options));\r\n\r\n        this.last = _last;\r\n        this.first = _first;\r\n    }\r\n\r\n    _handleOptions(options) {\r\n        if (options && typeof options === 'object') {\r\n            if (options.moreSeparators) {\r\n                if (options.wordSeparators) {\r\n                    console.warn(\r\n                        'Parsec WARNING: You cannot set both options ' +\r\n                            'wordSeparators & options.moreSeparator ; moreSeparator is ignored'\r\n                    );\r\n                    delete options.moreSeparator;\r\n                } else {\r\n                    options.wordSeparators = C.charIn(\r\n                        ' \\n:-,;' + options.moreSeparators\r\n                    );\r\n                }\r\n            }\r\n            return options;\r\n        } else {\r\n            return {};\r\n        }\r\n    }\r\n\r\n    spaces() {\r\n        return C.charIn(this.options.spacesCharacters)\r\n            .rep()\r\n            .map(spaces => spaces.join(''));\r\n    }\r\n\r\n    // returns a types number\r\n    number() {\r\n        return N.digit.rep().map(v => parseInt(v.join('')));\r\n    }\r\n\r\n    // returns a string representing numbers\r\n    digits() {\r\n        return N.digit.rep().map(v => v.join(''));\r\n    }\r\n\r\n    word() {\r\n        return this.options.letter.rep().map(v => v.join(''));\r\n    }\r\n\r\n    _wordSeparators() {\r\n        //TODO : replace second element by moreSeparators\r\n        return this.spaces().or(this.options.wordSeparators);\r\n    }\r\n\r\n    words(keepSpaces = true) {\r\n        if (keepSpaces) {\r\n            return F.try(this.word().or(this._wordSeparators()))\r\n                .rep()\r\n                .map(item => item.array());\r\n        } else {\r\n            const parser = F.try(\r\n                this._wordSeparators().optrep().thenRight(this.word())\r\n            );\r\n            return parser\r\n                .rep()\r\n                .thenLeft(this._wordSeparators().optrep())\r\n                .map(item => item.array());\r\n        }\r\n    }\r\n\r\n    wordsIn(array, keepSpaces = true) {\r\n        if (keepSpaces) {\r\n            return F.try(this.stringIn(array).or(this._wordSeparators()))\r\n                .rep()\r\n                .map(item => item.array());\r\n        } else {\r\n            const parser = F.try(\r\n                this._wordSeparators().optrep().thenRight(this.stringIn(array))\r\n            );\r\n            return parser\r\n                .rep()\r\n                .thenLeft(this._wordSeparators().optrep())\r\n                .map(item => item.array());\r\n        }\r\n    }\r\n\r\n    stringIn(array) {\r\n        const tryString = s => F.try(C.string(s));\r\n\r\n        if (array.length === 0) {\r\n            return tryString('').thenReturns(undefined);\r\n        }\r\n        if (array.length === 1) {\r\n            // TODO : use tryString\r\n            return F.try(C.string(array[0]));\r\n        }\r\n\r\n        // TODO: Comment reduce use\r\n        const initial = tryString(array[0]);\r\n        const workArray = array.slice(1);\r\n        return workArray.reduce(\r\n            (accu, next) => accu.or(tryString(next)),\r\n            initial\r\n        );\r\n    }\r\n\r\n    _wordSequence(stop) {\r\n        return F.not(stop);\r\n    }\r\n\r\n    wordsUntil(stop) {\r\n        if (typeof stop === 'string') {\r\n            return satisfyStringFast(stop);\r\n        }\r\n\r\n        if (Array.isArray(stop)) {\r\n            return satisfyArrayStringFast(stop);\r\n        }\r\n\r\n        return F.try(\r\n            this._wordSequence(stop).rep().then(F.eos).thenReturns(undefined)\r\n        )\r\n            .or(this._wordSequence(stop).rep().map(chars => chars.join('')))\r\n            .filter(v => v !== undefined);\r\n    }\r\n}\r\n\r\nfunction _last(values) {\r\n    return values[values.length - 1];\r\n}\r\n\r\nfunction _first(values) {\r\n    return values[0];\r\n}\r\n\r\n/**\r\n * Will work only if input.source is a String\r\n * @param string\r\n * @returns {Parser}\r\n */\r\nfunction satisfyStringFast(string) {\r\n    return new Parser((input, index = 0) => {\r\n        if (typeof input.source !== 'string') {\r\n            throw 'Input source must be a String';\r\n        }\r\n\r\n        const sourceIndex = input.source.indexOf(string, index);\r\n        if (sourceIndex > 0) {\r\n            return response.accept(\r\n                input.source.substring(index, sourceIndex),\r\n                input,\r\n                sourceIndex,\r\n                true\r\n            );\r\n        } else {\r\n            return response.reject(input.location(index), false);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Will work only if input.source is a String\r\n * Needs to be tested with ReactJS\r\n * @param string\r\n * @returns {Parser}\r\n */\r\nfunction satisfyArrayStringFast(array) {\r\n    return new Parser((input, index = 0) => {\r\n        if (typeof input.source !== 'string') {\r\n            throw 'Input source must be a String';\r\n        }\r\n\r\n        let sourceIndex = -1;\r\n\r\n        let i = 0;\r\n        while (sourceIndex < 0 && i < array.length) {\r\n            const needle = array[i];\r\n            sourceIndex = input.source.indexOf(needle, index);\r\n            i++;\r\n            if (sourceIndex > 0) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        //const sourceIndex = input.source.indexOf(string, index)\r\n\r\n        if (sourceIndex > 0) {\r\n            return response.accept(\r\n                input.source.substring(index, sourceIndex),\r\n                input,\r\n                sourceIndex,\r\n                true\r\n            );\r\n        } else {\r\n            return response.reject(input.location(index), false);\r\n        }\r\n    });\r\n}\r\n"]}