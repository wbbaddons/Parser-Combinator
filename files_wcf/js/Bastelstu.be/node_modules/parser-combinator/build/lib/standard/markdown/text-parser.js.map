{"version":3,"sources":["../../../../src/lib/standard/markdown/text-parser.js"],"names":["trimStartingLineFeed","str","replace","trimEndingLineFeed","stop","eos","or","lineFeed","charIn","pureText","not","rep","map","allChars","chars","join","italic","pureTextParser","char","thenRight","thenLeft","string","bold","code","text","formattedSequence","stopParser","formattedParagraph","blank","array","list","length","last","paragraph","parseText","line","offset","parse","ofString"],"mappings":"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","file":"text-parser.js","sourcesContent":["/**\r\n * Created by Simon on 14/12/2016.\r\n */\r\n\r\n/**\r\n * This parse a text paragraph\r\n * text can be \"simple\" text; bold, italic or a mix (sequence) of those\r\n * a paragraph ends with a blank line(\"\\n\\n\" or \"\\n  \\t  \\n\") or \"end of stream\" (F.eos())\r\n */\r\nimport {F, C} from '../../parsec/index';\r\nimport stream from '../../stream/index';\r\nimport T from './token';\r\n\r\nfunction trimStartingLineFeed(str) {\r\n    return str.replace(/^[\\s]*/, '');\r\n}\r\n\r\nfunction trimEndingLineFeed(str) {\r\n    return str.replace(/[\\s]*$/, '');\r\n}\r\n\r\nfunction stop() {\r\n    return F.eos.or(T.lineFeed()).or(C.charIn('*`'));\r\n}\r\n\r\nfunction pureText() {\r\n    return (\r\n        F.not(stop())\r\n            .rep() //  ['a','\\n','b'] -> 'a b'\r\n            // But on Windows, we will ignore the \\r\r\n            // inside line break will be put as space, but we clear initial or final \\n\r\n            .map(chars => {\r\n                let allChars = chars.join('');\r\n                return allChars.replace(/\\n/g, ' ').replace(/\\r/g, '');\r\n            })\r\n    );\r\n}\r\n\r\nfunction italic(pureTextParser) {\r\n    return C.char('*')\r\n        .thenRight(pureTextParser)\r\n        .thenLeft(C.char('*'))\r\n        .map(string => ({italic: string}));\r\n}\r\n\r\nfunction bold(pureTextParser) {\r\n    return C.string('**')\r\n        .thenRight(pureTextParser)\r\n        .thenLeft(C.string('**'))\r\n        .map(string => ({bold: string}));\r\n}\r\n\r\nfunction code(pureTextParser) {\r\n    return C.char('`')\r\n        .thenRight(pureTextParser)\r\n        .thenLeft(C.char('`'))\r\n        .map(string => ({code: string}));\r\n}\r\n\r\nfunction text(pureTextParser) {\r\n    return pureTextParser.map(string => ({text: string}));\r\n}\r\n\r\n/**\r\n * @param pureTextParser : defines if a text accept some chars or not\r\n * @param stopParser : defines if text stops at the end of line\r\n * @returns Parser\r\n */\r\nfunction formattedSequence(pureTextParser, stopParser) {\r\n    return bold(pureTextParser)\r\n        .or(italic(pureTextParser))\r\n        .or(text(pureTextParser))\r\n        .or(code(pureTextParser))\r\n        .rep()\r\n        .thenLeft(stopParser);\r\n}\r\n\r\nfunction formattedParagraph() {\r\n    return T.blank()\r\n        .thenRight(formattedSequence(pureText(), stop()))\r\n        .map(list => {\r\n            var array = list.array();\r\n            // We trim the first and last element of the paragraph\r\n            if (\r\n                array.length > 0 &&\r\n                typeof array[0] === 'object' &&\r\n                array[0].text\r\n            ) {\r\n                array[0].text = trimStartingLineFeed(array[0].text);\r\n                const last = array.length - 1;\r\n                array[last].text = trimEndingLineFeed(array[last].text);\r\n            }\r\n\r\n            return {paragraph: array};\r\n        });\r\n}\r\n\r\nfunction parseText(line, offset = 0) {\r\n    return formattedParagraph().parse(stream.ofString(line), offset);\r\n}\r\n\r\nexport default {\r\n    stop,\r\n    pureText,\r\n    italic,\r\n    bold,\r\n    code,\r\n    text,\r\n    formattedSequence,\r\n    formattedParagraph,\r\n    parse(line) {\r\n        return parseText(line, 0);\r\n    },\r\n};\r\n"]}