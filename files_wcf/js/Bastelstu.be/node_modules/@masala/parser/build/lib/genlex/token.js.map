{"version":3,"sources":["../../../src/lib/genlex/token.js"],"names":["Token","none","TKKeyword","value","some","TKIdent","TKNumber","TKString","TKChar","literal","tokenise","parse","input","index","get","map","accept","token","orLazyElse","reject","location","lazyRecoverWith","builder","keyword","ident","number","string","char","parser"],"mappings":";;;;;;qjBAAA;;;;;;;;AAQA;;;;AACA;;;;AACA;;;;;;;;;;;;IAEMA,K;AACF,qBAAc;AAAA;AAAE;;;;kCAEN;AACN,mBAAO,iBAAOC,IAAP,EAAP;AACH;;;gCAEO;AACJ,mBAAO,iBAAOA,IAAP,EAAP;AACH;;;iCAEQ;AACL,mBAAO,iBAAOA,IAAP,EAAP;AACH;;;iCAEQ;AACL,mBAAO,iBAAOA,IAAP,EAAP;AACH;;;+BAEM;AACH,mBAAO,iBAAOA,IAAP,EAAP;AACH;;;;;;IAGCC,S;;;AACF,uBAAYC,KAAZ,EAAmB;AAAA;;AAAA;;AAEf,cAAKA,KAAL,GAAaA,KAAb;AAFe;AAGlB;;;;kCAES;AACN,mBAAO,iBAAOC,IAAP,CAAY,KAAKD,KAAjB,CAAP;AACH;;;;EARmBH,K;;IAWlBK,O;;;AACF,qBAAYF,KAAZ,EAAmB;AAAA;;AAAA;;AAEf,eAAKA,KAAL,GAAaA,KAAb;AAFe;AAGlB;;;;gCAEO;AACJ,mBAAO,iBAAOC,IAAP,CAAY,KAAKD,KAAjB,CAAP;AACH;;;;EARiBH,K;;IAWhBM,Q;;;AACF,sBAAYH,KAAZ,EAAmB;AAAA;;AAAA;;AAEf,eAAKA,KAAL,GAAaA,KAAb;AAFe;AAGlB;;;;iCAEQ;AACL,mBAAO,iBAAOC,IAAP,CAAY,KAAKD,KAAjB,CAAP;AACH;;;;EARkBH,K;;IAWjBO,Q;;;AACF,sBAAYJ,KAAZ,EAAmB;AAAA;;AAAA;;AAEf,eAAKA,KAAL,GAAaA,KAAb;AAFe;AAGlB;;;;iCAEQ;AACL,mBAAO,iBAAOC,IAAP,CAAY,KAAKD,KAAjB,CAAP;AACH;;;;EARkBH,K;;IAWjBQ,M;;;AACF,oBAAYL,KAAZ,EAAmB;AAAA;;AAAA;;AAEf,eAAKA,KAAL,GAAaA,KAAb;AAFe;AAGlB;;;;+BAEM;AACH,mBAAO,iBAAOC,IAAP,CAAY,KAAKD,KAAjB,CAAP;AACH;;;;EARgBH,K;;AAWrB;;;AACA,SAASS,OAAT,CAAiBC,QAAjB,EAA2B;AACvB,WAAO,qBAAEC,KAAF,CAAQ,UAACC,KAAD,EAAQC,KAAR;AAAA,eACXD,MACKE,GADL,CACSD,KADT,EAEKE,GAFL,CAES;AAAA,mBACDL,SAASP,KAAT,EACKY,GADL,CACS;AAAA,uBACD,mBAASC,MAAT,CAAgBC,KAAhB,EAAuBL,KAAvB,EAA8BC,QAAQ,CAAtC,EAAyC,IAAzC,CADC;AAAA,aADT,EAIKK,UAJL,CAIgB;AAAA,uBACR,mBAASC,MAAT,CAAgBP,MAAMQ,QAAN,CAAeP,KAAf,CAAhB,EAAuC,KAAvC,CADQ;AAAA,aAJhB,CADC;AAAA,SAFT,EAWKQ,eAXL,CAWqB;AAAA,mBACb,mBAASF,MAAT,CAAgBP,MAAMQ,QAAN,CAAeP,KAAf,CAAhB,EAAuC,KAAvC,CADa;AAAA,SAXrB,CADW;AAAA,KAAR,CAAP;AAgBH;;AAED,IAAMI,QAAQ;AACVK,aAAS;AACLC,iBAAS;AAAA,mBAAS,IAAIrB,SAAJ,CAAcC,KAAd,CAAT;AAAA,SADJ;AAELqB,eAAO;AAAA,mBAAS,IAAInB,OAAJ,CAAYF,KAAZ,CAAT;AAAA,SAFF;AAGLsB,gBAAQ;AAAA,mBAAS,IAAInB,QAAJ,CAAaH,KAAb,CAAT;AAAA,SAHH;AAILuB,gBAAQ;AAAA,mBAAS,IAAInB,QAAJ,CAAaJ,KAAb,CAAT;AAAA,SAJH;AAKLwB,cAAM;AAAA,mBAAS,IAAInB,MAAJ,CAAWL,KAAX,CAAT;AAAA;AALD,KADC;AAQVyB,YAAQ;AACJL,iBAASd,QAAQ;AAAA,mBAASQ,MAAMM,OAAN,EAAT;AAAA,SAAR,CADL;AAEJC,eAAOf,QAAQ;AAAA,mBAASQ,MAAMO,KAAN,EAAT;AAAA,SAAR,CAFH;AAGJC,gBAAQhB,QAAQ;AAAA,mBAASQ,MAAMQ,MAAN,EAAT;AAAA,SAAR,CAHJ;AAIJC,gBAAQjB,QAAQ;AAAA,mBAASQ,MAAMS,MAAN,EAAT;AAAA,SAAR,CAJJ;AAKJC,cAAMlB,QAAQ;AAAA,mBAASQ,MAAMU,IAAN,EAAT;AAAA,SAAR;AALF;AARE,CAAd;;kBAiBeV,K","file":"token.js","sourcesContent":["/*\n * Parsec\n * https://github.com/d-plaindoux/parsec\n *\n * Copyright (c) 2016 Didier Plaindoux\n * Licensed under the LGPL2 license.\n */\n\nimport response from '../parsec/response';\nimport option from '../data/option';\nimport F from '../parsec/flow-bundle';\n\nclass Token {\n    constructor() {}\n\n    keyword() {\n        return option.none();\n    }\n\n    ident() {\n        return option.none();\n    }\n\n    number() {\n        return option.none();\n    }\n\n    string() {\n        return option.none();\n    }\n\n    char() {\n        return option.none();\n    }\n}\n\nclass TKKeyword extends Token {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n\n    keyword() {\n        return option.some(this.value);\n    }\n}\n\nclass TKIdent extends Token {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n\n    ident() {\n        return option.some(this.value);\n    }\n}\n\nclass TKNumber extends Token {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n\n    number() {\n        return option.some(this.value);\n    }\n}\n\nclass TKString extends Token {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n\n    string() {\n        return option.some(this.value);\n    }\n}\n\nclass TKChar extends Token {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n\n    char() {\n        return option.some(this.value);\n    }\n}\n\n// (Token -> Option 'a) -> Parser 'a Token\nfunction literal(tokenise) {\n    return F.parse((input, index) =>\n        input\n            .get(index)\n            .map(value =>\n                tokenise(value)\n                    .map(token =>\n                        response.accept(token, input, index + 1, true)\n                    )\n                    .orLazyElse(() =>\n                        response.reject(input.location(index), false)\n                    )\n            )\n            .lazyRecoverWith(() =>\n                response.reject(input.location(index), false)\n            )\n    );\n}\n\nconst token = {\n    builder: {\n        keyword: value => new TKKeyword(value),\n        ident: value => new TKIdent(value),\n        number: value => new TKNumber(value),\n        string: value => new TKString(value),\n        char: value => new TKChar(value),\n    },\n    parser: {\n        keyword: literal(token => token.keyword()),\n        ident: literal(token => token.ident()),\n        number: literal(token => token.number()),\n        string: literal(token => token.string()),\n        char: literal(token => token.char()),\n    },\n};\n\nexport default token;\n"]}