{"version":3,"sources":["../../../src/lib/parsec/flow-bundle.js"],"names":["string","parse","p","lazy","parameters","self","Array","isArray","input","index","apply","returns","v","accept","error","reject","location","eos","endOfStream","satisfy","predicate","get","filter","map","value","lazyRecoverWith","doTry","fold","offset","any","nop","not","then","or","subStream","length","occurrence","sequence","current","arguments","startsWith","thenReturns","moveUntil","stop","searchStringStart","searchArrayStringStart","rep","undefined","chars","join","dropTo","drop","try","source","sourceIndex","indexOf","substring","array","i","needle","s","subStreamAt","split"],"mappings":"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","file":"flow-bundle.js","sourcesContent":["/*\n * Parsec\n * https://github.com/d-plaindoux/parsec\n *\n * Copyright (c) 2016 Didier Plaindoux\n * Licensed under the LGPL2 license.\n */\n\nimport unit from '../data/unit.js';\nimport Parser from './parser';\nimport response from './response';\n\n// (Stream 'c -> number -> Response 'a 'c) -> Parser 'a 'c\nfunction parse(p) {\n    return new Parser(p);\n}\n\n// (('b -> Parser 'a 'c) * 'b)-> Parser 'a 'c\nfunction lazy(p, parameters, self = {}) {\n    if (parameters && !Array.isArray(parameters)) {\n        throw 'Lazy(parser, [params]) function expect parser parameters to be packed into an array';\n    }\n\n    // equivalent of p(...parameters), but would fail if parameters are undefined\n    // In some case, p is a function that require a 'this' bound to the function\n    // https://github.com/d-plaindoux/masala-parser/issues/9\n    return new Parser((input, index = 0) =>\n        p.apply(self, parameters).parse(input, index)\n    );\n}\n\n// 'a -> Parser 'a 'c\nfunction returns(v) {\n    return new Parser((input, index = 0) =>\n        response.accept(v, input, index, false)\n    );\n}\n\n// unit -> Parser 'a 'c\nfunction error() {\n    return new Parser((input, index = 0) =>\n        response.reject(input.location(index), false)\n    );\n}\n\n// unit -> Parser unit 'c\nfunction eos() {\n    return new Parser((input, index = 0) => {\n        if (input.endOfStream(index)) {\n            return response.accept(unit, input, index, false);\n        } else {\n            return response.reject(input.location(index), false);\n        }\n    });\n}\n\n// ('a -> boolean) -> Parser a 'c\n// index is forwarded at index +1\nfunction satisfy(predicate) {\n    return new Parser((input, index = 0) =>\n        input\n            .get(index)\n            .filter(predicate)\n            .map(value => response.accept(value, input, index + 1, true))\n            .lazyRecoverWith(() =>\n                response.reject(input.location(index), false)\n            )\n    );\n}\n\n// Parser 'a 'c -> Parser 'a 'c\nfunction doTry(p) {\n    return new Parser((input, index = 0) =>\n        p\n            .parse(input, index)\n            .fold(\n                accept => accept,\n                reject => response.reject(input.location(reject.offset), false)\n            )\n    );\n}\n\n// unit -> Parser 'a 'c\nfunction any() {\n    return satisfy(() => true);\n}\n\n// unit -> Parser 'a 'c\nfunction nop() {\n    return new Parser((input, index = 0) =>\n        response.accept([], input, index, true)\n    );\n}\n\n// Parser 'a ? -> Parser 'a 'a\nfunction not(p) {\n    return doTry(p).then(error()).or(any());\n}\n\n// int -> Parser (List 'a') a'\nfunction subStream(length) {\n    return any().occurrence(length);\n}\n\nfunction sequence() {\n    var current = nop();\n    for (let v in arguments) {\n        current = current.then(arguments[v]);\n    }\n    return current;\n}\n\nfunction startsWith(value) {\n    return nop().thenReturns(value);\n}\n\nfunction moveUntil(stop) {\n    if (typeof stop === 'string') {\n        return searchStringStart(stop);\n    }\n\n    if (Array.isArray(stop)) {\n        return searchArrayStringStart(stop);\n    }\n\n    return doTry(not(stop).rep().then(eos()).thenReturns(undefined))\n        .or(not(stop).rep().map(chars => chars.join('')))\n        .filter(v => v !== undefined);\n}\n\nfunction dropTo(stop) {\n    if (typeof stop === 'string') {\n        return moveUntil(stop).then(string(stop)).drop();\n    } else {\n        return moveUntil(stop).then(stop).drop();\n    }\n}\n\nexport default {\n    parse,\n    nop,\n    try: doTry,\n    any: any(),\n    subStream,\n    not: not,\n    lazy,\n    returns,\n    error: error(),\n    eos: eos(),\n    satisfy,\n    sequence,\n    startsWith,\n    moveUntil,\n    dropTo,\n};\n\n/**Optimization functions */\n\n/**\n * Will work only if input.source is a String\n * @param string\n * @returns {Parser}\n */\nfunction searchStringStart(string) {\n    return new Parser((input, index = 0) => {\n        if (typeof input.source !== 'string') {\n            throw 'Input source must be a String';\n        }\n\n        const sourceIndex = input.source.indexOf(string, index);\n        if (sourceIndex > 0) {\n            return response.accept(\n                input.source.substring(index, sourceIndex),\n                input,\n                sourceIndex,\n                true\n            );\n        } else {\n            return response.reject(input.location(index), false);\n        }\n    });\n}\n\n/**\n * Will work only if input.source is a String\n * Needs to be tested with ReactJS\n * @param string\n * @returns {Parser}\n */\nfunction searchArrayStringStart(array) {\n    return new Parser((input, index = 0) => {\n        if (typeof input.source !== 'string') {\n            throw 'Input source must be a String';\n        }\n\n        let sourceIndex = -1;\n\n        let i = 0;\n        while (sourceIndex < 0 && i < array.length) {\n            const needle = array[i];\n            sourceIndex = input.source.indexOf(needle, index);\n            i++;\n            if (sourceIndex > 0) {\n                break;\n            }\n        }\n\n        //const sourceIndex = input.source.indexOf(string, index)\n\n        if (sourceIndex > 0) {\n            return response.accept(\n                input.source.substring(index, sourceIndex),\n                input,\n                sourceIndex,\n                true\n            );\n        } else {\n            return response.reject(input.location(index), false);\n        }\n    });\n}\n\n// string -> Parser string char\n// index is forwarded at the length of the string\nexport function string(s) {\n    return new Parser((input, index = 0) => {\n        if (input.subStreamAt(s.split(''), index)) {\n            return response.accept(s, input, index + s.length, true);\n        } else {\n            return response.reject(input.location(index), false);\n        }\n    });\n}\n"]}