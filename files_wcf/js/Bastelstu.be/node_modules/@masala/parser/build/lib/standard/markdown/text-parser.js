'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * Created by Simon on 14/12/2016.
                                                                                                                                                                                                                                                                               */

/**
 * This parse a text paragraph
 * text can be "simple" text; bold, italic or a mix (sequence) of those
 * a paragraph ends with a blank line("\n\n" or "\n  \t  \n") or "end of stream" (F.eos())
 */


var _index = require('../../parsec/index');

var _index2 = require('../../stream/index');

var _index3 = _interopRequireDefault(_index2);

var _token = require('./token');

var _token2 = _interopRequireDefault(_token);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function trimStartingLineFeed(str) {
    return str.replace(/^[\s]*/, '');
}

function trimEndingLineFeed(str) {
    return str.replace(/[\s]*$/, '');
}

function stop() {
    return _index.F.eos.or(_token2.default.lineFeed()).or(_index.C.charIn('*`'));
}

function pureText() {
    return _index.F.not(stop()).rep() //  ['a','\n','b'] -> 'a b'
    // But on Windows, we will ignore the \r
    // inside line break will be put as space, but we clear initial or final \n
    .map(function (chars) {
        var allChars = chars.join('');
        return allChars.replace(/\n/g, ' ').replace(/\r/g, '');
    });
}

function italic(pureTextParser) {
    return _index.C.char('*').thenRight(pureTextParser).thenLeft(_index.C.char('*')).map(function (string) {
        return { italic: string };
    });
}

function bold(pureTextParser) {
    return _index.C.string('**').thenRight(pureTextParser).thenLeft(_index.C.string('**')).map(function (string) {
        return { bold: string };
    });
}

function code(pureTextParser) {
    return _index.C.char('`').thenRight(pureTextParser).thenLeft(_index.C.char('`')).map(function (string) {
        return { code: string };
    });
}

function text(pureTextParser) {
    return pureTextParser.map(function (string) {
        return { text: string };
    });
}

/**
 * @param pureTextParser : defines if a text accept some chars or not
 * @param stopParser : defines if text stops at the end of line
 * @returns Parser
 */
function formattedSequence(pureTextParser, stopParser) {
    return bold(pureTextParser).or(italic(pureTextParser)).or(text(pureTextParser)).or(code(pureTextParser)).rep().thenLeft(stopParser);
}

function formattedParagraph() {
    return _token2.default.blank().thenRight(formattedSequence(pureText(), stop())).map(function (list) {
        var array = list.array();
        // We trim the first and last element of the paragraph
        if (array.length > 0 && _typeof(array[0]) === 'object' && array[0].text) {
            array[0].text = trimStartingLineFeed(array[0].text);
            var last = array.length - 1;
            array[last].text = trimEndingLineFeed(array[last].text);
        }

        return { paragraph: array };
    });
}

function parseText(line) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    return formattedParagraph().parse(_index3.default.ofString(line), offset);
}

exports.default = {
    stop: stop,
    pureText: pureText,
    italic: italic,
    bold: bold,
    code: code,
    text: text,
    formattedSequence: formattedSequence,
    formattedParagraph: formattedParagraph,
    parse: function parse(line) {
        return parseText(line, 0);
    }
};
//# sourceMappingURL=text-parser.js.map