{"version":3,"sources":["../../../../src/lib/standard/markdown/text-parser.js"],"names":["trimStartingLineFeed","str","replace","trimEndingLineFeed","stop","eos","or","lineFeed","charIn","pureText","not","rep","map","allChars","chars","join","italic","pureTextParser","char","thenRight","thenLeft","string","bold","code","text","formattedSequence","stopParser","formattedParagraph","blank","array","list","length","last","paragraph","parseText","line","offset","parse","ofString"],"mappings":"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","file":"text-parser.js","sourcesContent":["/**\n * Created by Simon on 14/12/2016.\n */\n\n/**\n * This parse a text paragraph\n * text can be \"simple\" text; bold, italic or a mix (sequence) of those\n * a paragraph ends with a blank line(\"\\n\\n\" or \"\\n  \\t  \\n\") or \"end of stream\" (F.eos())\n */\nimport {F, C} from '../../parsec/index';\nimport stream from '../../stream/index';\nimport T from './token';\n\nfunction trimStartingLineFeed(str) {\n    return str.replace(/^[\\s]*/, '');\n}\n\nfunction trimEndingLineFeed(str) {\n    return str.replace(/[\\s]*$/, '');\n}\n\nfunction stop() {\n    return F.eos.or(T.lineFeed()).or(C.charIn('*`'));\n}\n\nfunction pureText() {\n    return (\n        F.not(stop())\n            .rep() //  ['a','\\n','b'] -> 'a b'\n            // But on Windows, we will ignore the \\r\n            // inside line break will be put as space, but we clear initial or final \\n\n            .map(chars => {\n                let allChars = chars.join('');\n                return allChars.replace(/\\n/g, ' ').replace(/\\r/g, '');\n            })\n    );\n}\n\nfunction italic(pureTextParser) {\n    return C.char('*')\n        .thenRight(pureTextParser)\n        .thenLeft(C.char('*'))\n        .map(string => ({italic: string}));\n}\n\nfunction bold(pureTextParser) {\n    return C.string('**')\n        .thenRight(pureTextParser)\n        .thenLeft(C.string('**'))\n        .map(string => ({bold: string}));\n}\n\nfunction code(pureTextParser) {\n    return C.char('`')\n        .thenRight(pureTextParser)\n        .thenLeft(C.char('`'))\n        .map(string => ({code: string}));\n}\n\nfunction text(pureTextParser) {\n    return pureTextParser.map(string => ({text: string}));\n}\n\n/**\n * @param pureTextParser : defines if a text accept some chars or not\n * @param stopParser : defines if text stops at the end of line\n * @returns Parser\n */\nfunction formattedSequence(pureTextParser, stopParser) {\n    return bold(pureTextParser)\n        .or(italic(pureTextParser))\n        .or(text(pureTextParser))\n        .or(code(pureTextParser))\n        .rep()\n        .thenLeft(stopParser);\n}\n\nfunction formattedParagraph() {\n    return T.blank()\n        .thenRight(formattedSequence(pureText(), stop()))\n        .map(list => {\n            var array = list.array();\n            // We trim the first and last element of the paragraph\n            if (\n                array.length > 0 &&\n                typeof array[0] === 'object' &&\n                array[0].text\n            ) {\n                array[0].text = trimStartingLineFeed(array[0].text);\n                const last = array.length - 1;\n                array[last].text = trimEndingLineFeed(array[last].text);\n            }\n\n            return {paragraph: array};\n        });\n}\n\nfunction parseText(line, offset = 0) {\n    return formattedParagraph().parse(stream.ofString(line), offset);\n}\n\nexport default {\n    stop,\n    pureText,\n    italic,\n    bold,\n    code,\n    text,\n    formattedSequence,\n    formattedParagraph,\n    parse(line) {\n        return parseText(line, 0);\n    },\n};\n"]}