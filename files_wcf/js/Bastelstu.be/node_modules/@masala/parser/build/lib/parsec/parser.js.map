{"version":3,"sources":["../../../src/lib/parsec/parser.js"],"names":["Parser","parse","f","bind","self","input","index","map","p","filter","v","a","flatMap","result","append","b","array","length","then","drop","thenRight","returns","choice","some","or","none","repeatable","l","occurrence","buffered","ofParser","hint","details","console","log","bindAccepted","accept_a","value","offset","fold","accept","accept_b","consumed","reject","location","reject_b","reject_a","occurrences","current","isAccepted"],"mappings":"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","file":"parser.js","sourcesContent":["/*\n * Parsec\n * https://github.com/d-plaindoux/parsec\n *\n * Copyright (c) 2016 Didier Plaindoux\n * Licensed under the LGPL2 license.\n */\n\n/*\n * Parsec: Direct Style Monadic Parser Combinators For The Real World\n *\n * http://research.microsoft.com/en-us/um/people/daan/download/papers/parsec-paper.pdf\n */\n\nimport stream from '../stream/index';\n\nimport option from '../data/option';\nimport list from '../data/list';\n\nimport response from './response';\n\n/**\n * Parser class\n */\nexport default class Parser {\n    // (Stream 'c -> number -> Response 'a 'c) -> Parser 'a 'c\n    constructor(parse) {\n        this.parse = parse;\n    }\n\n    // Parser 'a 'c => ('a -> Parser 'b 'c) -> Parser 'b 'c\n    flatMap(f) {\n        return bind(this, f);\n    }\n\n    // Parser 'a 'c => ('a -> 'b) -> Parser 'b 'c\n    map(f) {\n        var self = this;\n\n        return new Parser((input, index = 0) =>\n            self.parse(input, index).map(f)\n        );\n    }\n\n    // Parser 'a 'c => ('a -> boolean) -> Parser 'a 'c\n    filter(p) {\n        var self = this;\n\n        return new Parser((input, index = 0) =>\n            self.parse(input, index).filter(p)\n        );\n    }\n\n    // Parser 'a 'c => Comparable 'a -> Parser 'a 'c\n    match(v) {\n        return this.filter(a => a === v);\n    }\n\n    // Parser 'a 'c => Parser 'b 'c -> Parser ('a,'b) 'c\n    then(p) {\n        return this.flatMap(a =>\n            p.map(b => {\n                let result = list(a).append(list(b)).array();\n                if (result.length === 1) {\n                    return result[0];\n                } else {\n                    return result;\n                }\n            })\n        );\n    }\n\n    concat(p) {\n        return this.then(p);\n    }\n\n    drop() {\n        return this.map(() => []);\n    }\n\n    // Parser 'a 'c => Parser 'b 'c -> Parser 'a 'c\n    thenLeft(p) {\n        return this.then(p.drop());\n    }\n\n    // Parser 'a 'c => Parser 'b 'c -> Parser 'b 'c\n    thenRight(p) {\n        return this.drop().then(p);\n    }\n\n    // Parser 'a 'c => 'b -> Parser 'b 'c\n    thenReturns(v) {\n        return this.thenRight(returns(v));\n    }\n\n    // Parser 'a 'c -> Parser 'a 'c\n    or(p) {\n        return choice(this, p);\n    }\n\n    // Parser 'a 'c => unit -> Parser (Option 'a) 'c\n    opt() {\n        return this.map(option.some).or(returns(option.none()));\n    }\n\n    // Parser 'a 'c => unit -> Parser (List 'a) 'c\n    rep() {\n        return repeatable(this, () => true, l => l !== 0);\n    }\n\n    // Parser 'a 'c => number -> Parser (List 'a) 'c\n    occurrence(occurrence) {\n        return repeatable(this, l => l < occurrence, l => l === occurrence);\n    }\n\n    // Parser 'a 'c => unit -> Parser (List 'a) 'c\n    optrep() {\n        return repeatable(this, () => true, () => true);\n    }\n\n    // Parser 'a 'c => Parser 'b 'a -> Parser 'b 'c\n    chain(p) {\n        var self = this;\n\n        return new Parser((input, index = 0) =>\n            p.parse(stream.buffered(stream.ofParser(self, input)), index)\n        );\n    }\n\n    /**\n     * Prints a hint if the parser enters in this step\n     * @param hint\n     * @returns the equivalent Parser\n     */\n    // TODO: set details default at false; check tests\n    debug(hint, details = true) {\n        var f = p => {\n            if (details) {\n                console.log('[debug] : ', hint, p);\n            } else {\n                console.log('[debug] : ', hint);\n            }\n\n            return p;\n        };\n        return this.map(f);\n    }\n}\n\n// Response 'a 'c -> ('a -> Parser 'b 'c) -> Response 'b 'c\nfunction bindAccepted(accept_a, f) {\n    return f(accept_a.value)\n        .parse(accept_a.input, accept_a.offset)\n        .fold(\n            accept_b =>\n                response.accept(\n                    accept_b.value,\n                    accept_b.input,\n                    accept_b.offset,\n                    accept_a.consumed || accept_b.consumed\n                ),\n            reject_b =>\n                response.reject(\n                    accept_a.input.location(reject_b.offset),\n                    accept_a.consumed || reject_b.consumed\n                )\n        );\n}\n\n// Parser 'a 'c -> ('a -> Parser 'b 'c) -> Parser 'b 'c\nfunction bind(self, f) {\n    return new Parser((input, index = 0) =>\n        self\n            .parse(input, index)\n            .fold(accept_a => bindAccepted(accept_a, f), reject_a => reject_a)\n    );\n}\n\n// Parser 'a 'c -> Parser 'a 'c -> Parser 'a 'c\nfunction choice(self, f) {\n    return new Parser((input, index = 0) =>\n        self\n            .parse(input, index)\n            .fold(\n                accept => accept,\n                reject => (reject.consumed ? reject : f.parse(input, index))\n            )\n    );\n}\n\n// Parser 'a 'c -> unit -> Parser (List 'a) 'c\nfunction repeatable(self, occurrences, accept) {\n    return new Parser((input, index = 0) => {\n        var consumed = false,\n            value = list(),\n            offset = index,\n            current = self.parse(input, index),\n            occurrence = 0;\n\n        while (current.isAccepted() && occurrences(occurrence)) {\n            occurrence += 1;\n            value = value.append(list(current.value));\n            consumed = consumed || current.consumed;\n            offset = current.offset;\n            current = self.parse(input, current.offset);\n        }\n\n        if (accept(occurrence)) {\n            return response.accept(value, input, offset, consumed);\n        }\n\n        return response.reject(offset, consumed);\n    });\n}\n\n/*\n * Builders\n */\n\nfunction returns(v) {\n    return new Parser((input, index = 0) =>\n        response.accept(v, input, index, false)\n    );\n}\n"]}